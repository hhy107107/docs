> 想要更快的 Gradle 构建？ 在此处注册我们的构建缓存培训课程，了解 Gradle Enterprise 如何将构建速度提高多达 90%。

构建性能对您的生产力至关重要。构建完成的时间越长，您就越有可能被从开发流程中抽离出来。最重要的是，由于您每天运行构建多次，即使是很短的等待时间也会导致严重的中断。在 CI 上运行的构建也是如此：它们越快，您对新问题的反应就越快，您进行创新实验的能力就越大。
所有这一切都意味着值得投入一些时间和精力来尽可能快地构建。本节提供了几种让您可以探索以加快构建速度的途径，以及有关哪些类型的事情会降低构建性能以及原因的大量详细信息。

## Build scansh
Build scans是运行构建时发生的持久、可共享的记录。 通过Build scans，您可以深入了解您的构建，以识别和修复性能瓶颈。

如果您使用的是 Gradle 4.3+，您可以使用 --scan 命令行选项轻松创建构建扫描，例如 梯度构建——扫描。 对于较旧的 Gradle 版本，请参阅构建扫描插件用户手册了解如何启用构建扫描。
Gradle 在构建执行结束时显示构建扫描可用的 URL：
![图片](https://docs.gradle.org/current/userguide/img/performance/build-scan-url.png)
图 1. 构建输出末尾的构建扫描链接

接下来，本节将介绍一些可以提高构建性能的快速改进。 之后将更深入地使用build scan来分析您的构建。

## 简单的改进
关于性能调优的部分通常会从分析开始，而关于过早优化是万恶之源。 分析绝对重要，本节稍后会讨论它，但您可以做一些事情，只需轻按一下开关，就可以更好地影响您的所有构建。

### 使用最新的 Gradle 和 JVM 版本
Gradle 团队不断致力于提高 Gradle 构建不同方面的性能。 如果您使用的是旧版本的 Gradle，那么您将错过这项工作的好处。 始终跟上 Gradle 版本升级。 这样做的风险很低，因为 Gradle 团队确保了 Gradle 的次要版本之间的向后兼容性。 保持最新还可以更轻松地过渡到下一个主要版本，因为您会收到早期弃用警告。

升级主要版本通常同样容易。 只有以前不推荐使用的 API 和不推荐使用的行为才会在这些边界处失效。如果是第三方插件造成的，请第一时间告知作者，以免下个大版本出来时被屏蔽

由于 Gradle 在 JVM 上运行，后者性能的改进通常会使 Gradle 受益。 因此，您应该考虑使用最新的 JVM 主要版本运行 Gradle。

### 并行执行
大多数构建包含多个项目，其中一些项目通常相互独立。 然而，无论项目结构如何，Gradle 默认一次只运行一个任务（这将很快得到改进）。通过使用 `--parallel` 开关，您可以强制 Gradle 并行执行任务，只要这些任务位于不同的项目中。

一旦启用并行构建，您就会看到构建时间的巨大改进。 这些改进的程度取决于您的项目结构以及它们之间有多少依赖关系。 例如，执行时间由单个项目主导的构建根本不会有太多好处. 或者一个具有大量项目间依赖关系的项目，导致可以并行执行的任务很少。 但是大多数多项目构建应该会看到构建时间的值得提升。

> 并行构建要求项目在执行时解耦，即不同项目中的任务不得修改共享状态。 在广泛使用 --parallel 之前，请在多项目部分阅读有关该主题的更多信息。 另请注意，4.0 之前的 Gradle 版本可能会并行运行 clean 和 build 任务，从而导致失败。 在这些旧版本上，最好单独调用 clean。


您还可以通过将以下设置添加到项目的 gradle.properties 文件中，使并行构建成为项目的默认设置：

```
org.gradle.parallel=true
```

构建扫描为您提供了任务执行的可视化时间表和对当前并行度的快速印象，使您能够识别和消除瓶颈。

例如，在以下示例构建中，您可以在构建开始和结束时看到长时间运行的任务，它们是唯一正在执行的任务：

![图片](https://docs.gradle.org/current/userguide/img/performance/parallel-task-slow.png)
图 2. 并行执行的瓶颈

调整构建配置以尽早并行运行两个慢速任务，将整体构建时间从 8 秒减少到 5 秒：

![图片](https://docs.gradle.org/current/userguide/img/performance/parallel-task-fast.png)
图 3. 优化的并行执行
这就是快速胜利的结束。从现在开始，提高构建性能将需要一些润滑脂。首先，也许是最重要的一步：找出构建的哪些部分速度慢以及原因。

### 文件系统监视
Gradle 与文件系统进行了很多对话，尤其是在尝试解析构建的输入和输出的状态时。 为了避免不必要的 I/O，在整个构建过程中都会维护内存中的虚拟文件系统。 文件系统监视功能允许 Gradle 在构建之间保留此内存数据，从而进一步显着减少 I/O。影响取决于许多因素，但与构建的最新程度成正比。 因此，它对于逐步构建小的更改最有用。

Gradle 7.0 文件系统监视在 Gradle 支持该功能的操作系统上默认启用。

相应部分阅读有关此功能的更多信息。

## 使用build scan 进行分析
在分析构建的上下文中使用构建扫描时，诊断早期阶段的主要关注领域是性能页面。 要到达那里，请单击左侧导航菜单中的“性能”，或点击以下构建扫描主页屏幕截图中突出显示的链接：
![图片](https://docs.gradle.org/current/userguide/img/performance/build-scan-home.png)
图 4. 构建扫描主页上的性能页面链接

性能页面为您提供了构建的不同阶段完成所需时间的细分。正如您从以下屏幕截图中看到的那样，您可以看到 Gradle 启动、配置构建项目、解决依赖关系和执行任务所需的时间。 您还可以获得有关环境属性的详细信息，例如是否使用了守护程序.

![图片](https://docs.gradle.org/current/userguide/img/performance/build-scan-performance-page.png)
图 5. 构建扫描性能页面

## 配置
如构建生命周期章节所述，Gradle 构建经历了 3 个阶段：初始化、配置和执行。 这里要理解的重要一点是，无论将运行哪些任务，配置代码都会始终执行。 这意味着在配置期间执行的任何昂贵的工作都会减慢每次调用的速度，即使是像 gradle help 和 gradle tasks 这样的简单工作。
在上面的构建扫描性能页面中，您可以看到构建配置花费了 16 秒以上。 单击页面顶部的“配置”选项卡将将此阶段分解为其组成部分，从而揭示导致任何缓慢的原因。
![图片](https://docs.gradle.org/current/userguide/img/performance/build-scan-configuration-breakdown.png)
图 6. 构建扫描配置分解

在这里，您可以按应用时间的降序查看应用于项目的脚本和插件。 最慢的插件和脚本应用程序是优化的最佳候选者，您可以进一步挖掘列表中的这些项目。例如，脚本 script-b.gradle 应用了一次，但花了 3 秒 - 您可以展开该行以查看它是如何以及在何处应用到构建的。
![图片](https://docs.gradle.org/current/userguide/img/performance/script-b-application.png)
图 7. 显示 script-b.gradle 在构建中的应用

你可以看到这个脚本被应用了一次，项目 `:app1` 从该项目的 `build.gradle` 文件内部。
接下来的几个小节介绍了有助于缩短配置时间并解释它们为何起作用的技术。

### 明智地应用插件
您应用于项目的每个插件和脚本都会增加整体配置时间。 一些插件比其他插件有更大的影响。 这并不意味着你应该避免使用插件，但你应该注意只在需要它们的地方应用它们。 例如，通过 `allprojects {}` 或 `subprojects {}` 将插件应用到所有项目很容易，即使不是每个项目都需要它们。
在上面的构建扫描示例中，您可以看到脚本 `script-a.gradle` 应用于构建内部的 3 个项目：
![图片](https://docs.gradle.org/current/userguide/img/performance/script-a-application.png)
图 8. 显示 script-a.gradle 在构建中的应用

此脚本需要 1 秒才能运行，并且由于它从根构建脚本应用于 3 个项目，因此会在配置阶段引入 3 秒延迟。
理想情况下，插件和脚本不应该产生大量的配置时间成本。 如果他们这样做了，重点应该放在改进它们上。 尽管如此，在具有许多模块和大量配置时间的项目中，您应该花一点时间来识别任何具有显着影响的插件。

### 避免昂贵或阻塞的工作
如您所见，您将希望避免在配置阶段进行耗时的工作，但有时它可能会潜入您的构建中而不是显而易见的地方。如果该代码在构建文件中，那么在配置期间加密数据或调用远程服务时通常很清楚。 但是这样的逻辑更常见于插件和偶尔的自定义任务类中。插件的 apply() 方法或任务的构造函数中的任何昂贵工作都应该是一个危险信号。 最常见且不太明显的错误是在配置时解决依赖关系，这将在下面的单独章节中进行介绍。

### 静态的编译任务和插件
如果您的构建逻辑由使用静态编译的 JVM 语言（如 Java 或 Kotlin）编写的插件和使用 Gradle Kotlin DSL 编写的构建脚本组成，然后你可以跳过这个并继续下一部分。

插件和偶尔的任务在配置阶段执行工作。 这些通常是用 Groovy 编写的，因为它的语法简洁、对 JDK 的 API 扩展以及使用闭包的函数式方法。 但是，重要的是要记住，动态 Groovy 中的方法调用会产生少量成本。 当您在许多项目中重复大量方法调用时，成本可能会增加。

可以通过在 Groovy 类（如果可能）上使用 @CompileStatic 或使用静态编译语言（如 Java）编写这些类来降低成本。 这仅适用于您公开发布的大型项目或插件（因为它们可能被其他用户应用于大型项目）。 如果您确实需要动态 Groovy，只需将 @CompileDynamic 用于相关方法即可。
注意：您在构建脚本中习惯使用的 DSL 很大程度上依赖于 Groovy 的动态特性，因此如果您想在插件中使用静态编译，您将不得不切换到更传统的类似 Java 的语法。 例如，要创建一个新的复制任务，您可以使用如下代码：

**src/main/groovy/MyPlugin.groovy**
```
project.tasks.register('copyFiles', Copy) { Task t ->
    t.into(project.layout.buildDirectory.dir('output'))
    t.from(project.configurations.getByName('compile'))
}
```
您可以看到此示例如何使用 register() 和 getByName() 方法，这些方法可用于所有 Gradle“域对象容器”，如任务、配置、依赖项、扩展等。一些集合具有专用类型，TaskContainer 是其中之一 它们具有有用的额外方法，例如采用任务类型的 create 方法。

## 依赖解析
软件项目依赖依赖解析来简化第三方库和其他依赖项到构建中的集成。 这确实是有代价的，因为 Gradle 必须联系远程服务器以了解这些依赖关系并在必要时下载它们。 高级缓存有助于极大地加快速度，但您仍然需要注意下面将讨论的一些陷阱。

### 最小化动态和快照版本
动态版本，例如“2.+”和快照（或更改）版本强制 Gradle 联系远程存储库以了解是否有新版本或快照可用。 默认情况下，Gradle 只会每 24 小时执行一次检查，但这可以更改。 在构建文件和初始化脚本中注意 cacheDynamicVersionsFor 和 cacheChangingModulesFor，以防它们被设置为非常短的周期或完全禁用。 否则，您可能会谴责您的构建用户频繁进行比正常速度慢的构建，而不是每天一次比正常速度慢的构建。

您可以通过构建扫描找到所有具有动态版本的依赖项
![图片](https://docs.gradle.org/current/userguide/img/performance/dependency-dynamic-versions.png)

图 9. 使用动态版本查找依赖项
您也许可以使用固定版本——例如“1.2”和“3.0.3.GA”——在这种情况下，Gradle 将始终使用缓存版本。 但如果您需要使用动态和快照版本，请确保调整缓存设置以最好地满足您的需求。

### 不要在配置时解决依赖关系


